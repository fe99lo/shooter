<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sharp Shooter: Forest Hunt</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4ade80">

    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="asset-processor.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Rajdhani:wght@600;700&display=swap');
        body { margin: 0; overflow: hidden; background-color: #1a2e1a; font-family: 'Rajdhani', sans-serif; touch-action: none; user-select: none; -webkit-touch-callout: none; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; outline: none; }
        #root { position: relative; width: 100vw; height: 100vh; z-index: 10; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* The forest background is now handled via CSS for perfect screen coverage */
        .forest-bg { 
            background-image: url('forest-bg.jpg'); 
            background-size: cover; 
            background-position: center; 
            background-color: #1a2e1a; /* Fallback */
            position: absolute; inset: 0; z-index: 0; pointer-events: none; 
            filter: brightness(0.7); /* Darkens slightly so UI pops */
        }
        
        .pop-text { font-family: 'Permanent Marker', cursive; text-shadow: 2px 4px 0px #000; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes popIn { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); } }
        .rank-up { animation: glowPulse 2s infinite; }
        @keyframes glowPulse { 0% { text-shadow: 0 0 5px #ffd700; } 50% { text-shadow: 0 0 20px #ffd700, 0 0 30px #ff8c00; } 100% { text-shadow: 0 0 5px #ffd700; } }
    </style>
</head>
<body>
    <div class="forest-bg"></div>
    <div id="root"></div>

    <script type="text/babel">
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => navigator.serviceWorker.register('/service-worker.js').catch(e => console.log(e)));
        }

        const { useState, useEffect, useRef } = React;

        function App() {
            const [gameState, setGameState] = useState('LOADING'); 
            const scoreRef = useRef(null), accuracyRef = useRef(null), rankRef = useRef(null), comboRef = useRef(null), announcerRef = useRef(null), canvasRef = useRef(null);
            
            // Asset storage
            const assets = useRef({ catapult: null, birdFly: null, birdHop: null, stone: null });

            // Run asset pipeline on startup
            useEffect(() => {
                const loadAssets = async () => {
                    try {
                        // The code resizes and cleans the images automatically here!
                        // Syntax: processImage(filename, width, height, removeCheckerboard)
                        assets.current.catapult = await AssetProcessor.processImage('catapult.png', 120, 180, true);
                        assets.current.birdFly = await AssetProcessor.processImage('bird-fly-spritesheet.png', 300, 100, true); // Assuming sprite sheet
                        assets.current.birdHop = await AssetProcessor.processImage('bird-hopper.png', 60, 60, true);
                        assets.current.stone = await AssetProcessor.processImage('stone.png', 20, 20, true);
                        setGameState('MENU');
                    } catch (err) {
                        console.error("Asset loading failed, falling back to shapes.", err);
                        setGameState('MENU'); // Still let them play with shapes if images fail
                    }
                };
                loadAssets();
            }, []);

            // Synthesize Audio
            const audioCtx = useRef(null);
            const playSound = (type) => {
                if (!audioCtx.current) audioCtx.current = new (window.AudioContext || window.webkitAudioContext)();
                const ctx = audioCtx.current;
                const osc = ctx.createOscillator(), gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                
                if (type === 'stretch') { osc.type = 'triangle'; osc.frequency.setValueAtTime(150, ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(250, ctx.currentTime + 0.1); gain.gain.setValueAtTime(0.05, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1); osc.start(); osc.stop(ctx.currentTime + 0.1); }
                if (type === 'shoot') { osc.type = 'sine'; osc.frequency.setValueAtTime(300, ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.2); gain.gain.setValueAtTime(0.2, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2); osc.start(); osc.stop(ctx.currentTime + 0.2); }
                if (type === 'hit') { osc.type = 'square'; osc.frequency.setValueAtTime(600, ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.1); gain.gain.setValueAtTime(0.15, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1); osc.start(); osc.stop(ctx.currentTime + 0.1); }
            };

            // GAME ENGINE LOOP
            useEffect(() => {
                if (gameState !== 'PLAYING' || !canvasRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d', { alpha: true });
                const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
                window.addEventListener('resize', resize); resize();

                // Core Metrics
                let score = 0, shotsFired = 0, birdsHit = 0, combo = 0, misses = 0, accuracy = 100;
                let currentRank = "ROOKIE";

                const triggerAppreciation = (msg, color) => {
                    if (!announcerRef.current) return;
                    const el = announcerRef.current;
                    el.innerText = msg; el.style.color = color;
                    el.style.animation = 'none'; void el.offsetWidth;
                    el.style.animation = 'popIn 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
                };

                const updateMetrics = () => {
                    accuracy = shotsFired > 0 ? Math.round((birdsHit / shotsFired) * 100) : 100;
                    if (score > 1000 && accuracy > 70) currentRank = "THE G ðŸ‘‘";
                    else if (score > 400) currentRank = "SHARP SHOOTER";
                    else if (score > 150) currentRank = "HUNTER";
                    else currentRank = "ROOKIE";

                    if (scoreRef.current) scoreRef.current.innerText = score;
                    if (accuracyRef.current) accuracyRef.current.innerText = accuracy + '%';
                    if (comboRef.current) comboRef.current.innerText = combo > 1 ? `COMBO x${combo} ðŸ”¥` : '';
                    if (rankRef.current) {
                        rankRef.current.innerText = currentRank;
                        rankRef.current.className = currentRank === "THE G ðŸ‘‘" ? "text-3xl text-yellow-400 rank-up" : "text-xl text-gray-300";
                    }
                };

                // PHYSICS ENTITIES
                const anchor = { x: 150, y: canvas.height - 150 };
                let drag = { active: false, x: anchor.x, y: anchor.y };
                let catapultAngle = 0; // Dynamic rotation angle
                
                let stones = [], birds = [], particles = [], floatingTexts = [];

                class FloatingText {
                    constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.life = 1.0; }
                    update(dt) { this.y -= 50 * dt; this.life -= dt; }
                    draw(ctx) { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.font = "bold 24px 'Permanent Marker'"; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1.0; }
                }

                class Stone {
                    constructor(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.radius = 8; this.active = true; }
                    update(dt) {
                        this.vy += 800 * dt; 
                        this.x += this.vx * dt; this.y += this.vy * dt;
                        if (this.y > canvas.height || this.x > canvas.width || this.x < 0) { this.active = false; misses++; combo = 0; updateMetrics(); }
                    }
                    draw(ctx) {
                        if (assets.current.stone) {
                            ctx.drawImage(assets.current.stone, this.x - 10, this.y - 10);
                        } else {
                            ctx.fillStyle = '#9ca3af'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                        }
                    }
                }

                class Bird {
                    constructor() {
                        this.type = Math.random() > 0.4 ? 'flyer' : 'hopper'; 
                        this.radius = 20;
                        this.direction = -1; 
                        this.x = canvas.width + 50;
                        this.speed = (120 + (score * 0.1)) * (Math.random() * 0.5 + 0.8);
                        
                        if (this.type === 'flyer') {
                            this.y = Math.random() * (canvas.height * 0.5) + 50;
                            this.baseY = this.y;
                            this.sineFreq = Math.random() * 3 + 2;
                            this.time = 0;
                        } else {
                            this.y = canvas.height - 80; 
                            this.vy = -Math.random() * 300 - 300; 
                        }
                        this.active = true;
                        this.points = Math.floor(this.speed / 5);
                    }
                    update(dt) {
                        this.x += this.speed * this.direction * dt;
                        if (this.type === 'flyer') {
                            this.time += dt;
                            this.y = this.baseY + Math.sin(this.time * this.sineFreq) * 60;
                        } else if (this.type === 'hopper') {
                            this.vy += 900 * dt; 
                            this.y += this.vy * dt;
                            if (this.y > canvas.height - 80) { this.y = canvas.height - 80; this.vy = -Math.random() * 300 - 200; }
                        }
                        if (this.x < -50) this.active = false;
                    }
                    draw(ctx) {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        if (this.type === 'flyer' && assets.current.birdFly) {
                            // Simple fallback animation if it's a sprite sheet, just draws the first frame for now
                            ctx.drawImage(assets.current.birdFly, 0, 0, 100, 100, -25, -25, 50, 50); 
                        } else if (this.type === 'hopper' && assets.current.birdHop) {
                            ctx.drawImage(assets.current.birdHop, -30, -30);
                        } else {
                            // Fallback Shapes
                            ctx.fillStyle = this.type === 'flyer' ? '#3b82f6' : '#eab308';
                            ctx.beginPath(); ctx.ellipse(0, 0, this.radius, this.radius * 0.7, 0, 0, Math.PI * 2); ctx.fill();
                        }
                        ctx.restore();
                    }
                }

                class Particle {
                    constructor(x, y, color) { this.x = x; this.y = y; this.color = color; const angle = Math.random() * Math.PI * 2, speed = Math.random() * 300 + 50; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.life = 1.0; }
                    update(dt) { this.vy += 600 * dt; this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt * 2.5; }
                    draw(ctx) { if (this.life <= 0) return; ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x | 0, this.y | 0, 3, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; }
                }

                // INPUT HANDLING
                const getMousePos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    return { x: clientX - rect.left, y: clientY - rect.top };
                };

                const startDrag = (e) => {
                    if (e.touches && e.touches.length > 1) return;
                    const pos = getMousePos(e);
                    if (Math.hypot(pos.x - anchor.x, pos.y - anchor.y) < 150) {
                        drag.active = true; drag.x = pos.x; drag.y = pos.y;
                        if (audioCtx.current) audioCtx.current.resume(); playSound('stretch');
                    }
                };

                const handleDrag = (e) => {
                    if (!drag.active) return;
                    e.preventDefault();
                    const pos = getMousePos(e);
                    const dx = pos.x - anchor.x, dy = pos.y - anchor.y;
                    const dist = Math.hypot(dx, dy), maxPull = 120;
                    
                    if (dist > maxPull) { drag.x = anchor.x + (dx / dist) * maxPull; drag.y = anchor.y + (dy / dist) * maxPull; } 
                    else { drag.x = pos.x; drag.y = pos.y; }

                    // DYNAMIC ROTATION Math
                    // Aiming opposite of drag direction.
                    catapultAngle = Math.atan2(drag.y - anchor.y, drag.x - anchor.x) - (Math.PI / 2);
                    // Lock the rotation slightly so it doesn't spin wildly backwards
                    if (catapultAngle > Math.PI / 2) catapultAngle = Math.PI / 2;
                    if (catapultAngle < -Math.PI / 2) catapultAngle = -Math.PI / 2;
                };

                const releaseDrag = (e) => {
                    if (!drag.active) return;
                    drag.active = false;
                    const dx = anchor.x - drag.x, dy = anchor.y - drag.y;
                    if (Math.hypot(dx, dy) > 20) {
                        stones.push(new Stone(drag.x, drag.y, dx * 9, dy * 9));
                        shotsFired++; playSound('shoot');
                    }
                    drag.x = anchor.x; drag.y = anchor.y;
                    catapultAngle = 0; // Reset catapult aim to straight up
                };

                canvas.addEventListener('mousedown', startDrag); canvas.addEventListener('mousemove', handleDrag, { passive: false }); window.addEventListener('mouseup', releaseDrag);
                canvas.addEventListener('touchstart', startDrag, { passive: false }); canvas.addEventListener('touchmove', handleDrag, { passive: false }); window.addEventListener('touchend', releaseDrag);

                // LOOP
                let lastTime = performance.now();
                let spawnTimer = 0;
                let animationFrameId;

                const gameLoop = (now) => {
                    const dt = Math.min((now - lastTime) / 1000, 0.05);
                    lastTime = now;

                    spawnTimer -= dt;
                    if (spawnTimer <= 0) {
                        birds.push(new Bird());
                        spawnTimer = Math.max(0.6, 2.5 - (score / 1500)); 
                    }

                    stones.forEach(s => s.update(dt)); birds.forEach(b => b.update(dt)); particles.forEach(p => p.update(dt)); floatingTexts.forEach(f => f.update(dt));

                    // Collisions
                    for (let s of stones) {
                        if (!s.active) continue;
                        for (let b of birds) {
                            if (!b.active) continue;
                            if (Math.hypot(s.x - b.x, s.y - b.y) < s.radius + b.radius) {
                                s.active = false; b.active = false;
                                birdsHit++; combo++; misses = 0;
                                const pts = b.points * combo; score += pts; playSound('hit');
                                
                                floatingTexts.push(new FloatingText(b.x, b.y, `+${pts}`, '#4ade80'));
                                for(let i=0; i<20; i++) particles.push(new Particle(b.x, b.y, b.type==='flyer'?'#3b82f6':'#eab308'));
                                
                                if (combo === 3) triggerAppreciation("SHARP!", "#38bdf8");
                                if (combo === 6) triggerAppreciation("RESPECT EARNED!", "#fbbf24");
                                updateMetrics();
                                break;
                            }
                        }
                    }

                    stones = stones.filter(s => s.active); birds = birds.filter(b => b.active);
                    particles = particles.filter(p => p.life > 0); floatingTexts = floatingTexts.filter(f => f.life > 0);

                    // Render World
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // --- DRAW DYNAMIC CATAPULT ---
                    ctx.save();
                    ctx.translate(anchor.x, anchor.y);
                    ctx.rotate(catapultAngle); // ROTATES BASED ON MOUSE DRAG
                    
                    // Back rubber band
                    ctx.strokeStyle = '#854d0e'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(-20, -50); 
                    
                    // Transform drag coords to relative catapult coords
                    const dx = drag.x - anchor.x; const dy = drag.y - anchor.y;
                    const rotatedDragX = dx * Math.cos(-catapultAngle) - dy * Math.sin(-catapultAngle);
                    const rotatedDragY = dx * Math.sin(-catapultAngle) + dy * Math.cos(-catapultAngle);
                    
                    ctx.lineTo(rotatedDragX, rotatedDragY); ctx.stroke();
                    
                    // Render Processed Wood Slingshot Image
                    if (assets.current.catapult) {
                        ctx.drawImage(assets.current.catapult, -60, -90); // Center the image based on the processed 120x180 size
                    } else {
                        // Fallback Shapes
                        ctx.fillStyle = '#78350f'; ctx.fillRect(-8, 0, 16, 100); 
                        ctx.beginPath(); ctx.moveTo(-8, 20); ctx.lineTo(-20, -60); ctx.lineTo(-10, -60); ctx.lineTo(0, 20); ctx.fill(); 
                        ctx.beginPath(); ctx.moveTo(8, 20); ctx.lineTo(20, -60); ctx.lineTo(10, -60); ctx.lineTo(0, 20); ctx.fill(); 
                    }

                    // Pouch
                    if (drag.active) {
                        ctx.fillStyle = '#b45309'; ctx.beginPath(); ctx.ellipse(rotatedDragX, rotatedDragY, 15, 8, 0, 0, Math.PI*2); ctx.fill();
                    }

                    // Front rubber band
                    ctx.beginPath(); ctx.moveTo(20, -50); ctx.lineTo(rotatedDragX, rotatedDragY); ctx.stroke();
                    ctx.restore();

                    // Entities
                    birds.forEach(b => b.draw(ctx)); stones.forEach(s => s.draw(ctx)); particles.forEach(p => p.draw(ctx)); floatingTexts.forEach(f => f.draw(ctx));

                    animationFrameId = requestAnimationFrame(gameLoop);
                };

                updateMetrics();
                animationFrameId = requestAnimationFrame(gameLoop);

                return () => { cancelAnimationFrame(animationFrameId); window.removeEventListener('resize', resize); };
            }, [gameState]);

            return (
                <div className="w-full h-full flex flex-col justify-between pointer-events-none">
                    
                    {gameState === 'LOADING' && (
                        <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-50 pointer-events-auto">
                            <div className="text-3xl text-green-400 font-bold animate-pulse tracking-widest">LOADING ASSETS...</div>
                        </div>
                    )}

                    {gameState === 'PLAYING' && (
                        <>
                            <canvas ref={canvasRef} className="absolute inset-0 pointer-events-auto block"></canvas>
                            {/* HUD Layout remains the same */}
                            <div className="w-full px-6 py-4 flex justify-between items-start z-20">
                                <div className="bg-black/50 backdrop-blur-md rounded-xl p-4 border-2 border-green-800/80 shadow-lg">
                                    <div className="text-gray-400 text-xs font-bold tracking-widest uppercase">Reputation</div>
                                    <div ref={rankRef} className="text-xl text-gray-200 drop-shadow-md font-bold mt-1">ROOKIE</div>
                                    <div ref={comboRef} className="text-orange-400 font-black mt-2 h-6 drop-shadow-md text-lg"></div>
                                </div>
                                <div className="flex flex-col items-end gap-3">
                                    <div className="bg-black/50 backdrop-blur-md rounded-xl p-4 border-2 border-green-800/80 min-w-[140px] text-right">
                                        <div className="text-gray-400 text-xs font-bold tracking-widest uppercase">Score</div>
                                        <div ref={scoreRef} className="text-5xl text-white font-black drop-shadow-md tracking-tighter">0</div>
                                    </div>
                                    <div className="bg-black/50 backdrop-blur-md rounded-xl px-4 py-2 border-2 border-green-800/80 flex items-center gap-3">
                                        <div className="text-gray-400 text-xs font-bold uppercase">Accuracy</div>
                                        <div ref={accuracyRef} className="text-green-400 font-black text-lg">100%</div>
                                    </div>
                                </div>
                            </div>
                            <div ref={announcerRef} className="absolute top-1/3 left-1/2 -translate-x-1/2 -translate-y-1/2 text-5xl md:text-7xl font-black text-center pop-text opacity-0 z-30 pointer-events-none w-full tracking-widest drop-shadow-[0_0_20px_rgba(0,0,0,1)]"></div>
                        </>
                    )}

                    {gameState === 'MENU' && (
                        <div className="absolute inset-0 bg-black/70 backdrop-blur-sm flex flex-col items-center justify-center pointer-events-auto z-50">
                            <h1 className="text-5xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-b from-green-300 to-green-600 mb-2 tracking-widest text-center drop-shadow-lg">SHARP SHOOTER</h1>
                            <h2 className="text-2xl md:text-4xl text-orange-300 mb-8 font-bold tracking-widest drop-shadow-md">FOREST HUNT</h2>
                            <button onClick={() => setGameState('PLAYING')} className="border-4 border-green-500 bg-green-900/40 text-white px-12 py-5 text-2xl md:text-3xl font-black rounded-2xl hover:bg-green-500 hover:text-black transition-all duration-300 tracking-widest shadow-lg uppercase">
                                ENTER THE FOREST
                            </button>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
